var fs = require('fs');
var crypto = require('crypto'); // for hashes
var common = require('common');
var path = require('path');

var queue = require('./queue');
var cache = require('./cache');

var parse = function(src) {
	var strs = [];
	var modules = [];

	var save = function(_, str) {
		return strs.push(str)-1;
	};

	src = src.replace(/'((?:(?:\\')|[^'])*)'/g, save);                  // save ' based strings
	src = src.replace(/"((?:(?:\\")|[^"])*)"/g, save);                  // save " based strings
	src = src.replace(/(\n|^).*\/\/\s*node\s*[-]?\s*only\s*\n/g, '$1'); // remove all ignore lines
	src = src.replace(/\/\/.*/g, '');                                   // remove all comments
	src = src.replace(/\/\*([^*]|\*[^\/])*\*\//g, '');                  // remove all multiline comments

	src.replace(/(?:^|[^\w.])require(?:\.push)?\s*\(\s*((?:\d+(?:\s*,\s*)?)+)\s*\)(?:[^\w]|$)/g, function(_, i) {
		i.split(/\s*,\s/g).forEach(function(i) {
			modules.push(strs[i]);
		});
	});	

	return modules;
};
var exists = function(cwd, paths, callback) {
	if (!callback) {
		callback = paths;
		paths = cwd;
	} else {
		paths = paths.map(path.join.bind(path, cwd));		
	}
	
	common.step([
		function(next) {
			paths.forEach(function(loc) {
				path.exists(loc, next.parallel().bind(null, null));
			});
		},
		function(exists) {
			paths = paths.filter(function(_, i) {
				return exists[i];
			});
			callback(null, paths);
		}
	], callback);
};
var minify = function(src, type, callback) {
	type = {simple:'SIMPLE_OPTIMIZATIONS', advanced:'ADVANCED_OPTIMIZATIONS'}[type && type.toString().toLowerCase()] || 'SIMPLE_OPTIMIZATIONS';
	
	var post = require('http').request({
		method: 'POST',
		port: 80,
		host: 'closure-compiler.appspot.com',
		path: '/compile',
		headers: {'content-type':'application/x-www-form-urlencoded'}
	});
	post.end('output_info=compiled_code&compilation_level='+type+'&warning_level=default&js_code='+encodeURIComponent(src));

	post.on('error', callback);
	post.on('response', function(response) {
		var buf = '';

		response.setEncoding('utf-8');
		response.on('data', function(data) {
			buf += data;
		});
		response.on('close', callback);
		response.on('end', function() {
			callback(null, (!buf.trim() || (/^Error/).test(buf)) ? src : buf);
		});
	});
};

var findModule = function(module, cwd, callback) {
	module = module.replace(/\.js$/i, '');
	
	var candidates = ['js_modules/'+module+'.js', 'js_modules/'+module];
	
	var find = function(dir, callback) {
		common.step([
			function(next) {
				exists(dir, candidates, next);
			},
			function(paths) {
				if (paths.length) {
					callback(null, paths[0]);
					return;
				}
				
				var parent = path.join(dir, '..');
				
				if (parent === dir) {
					callback(new Error('module '+module+' could not be found from ' + cwd));
					return;
				}
				find(parent, callback);
			}
			
		], callback);		
	};
	
	common.step([
		function(next) {
			find(cwd, next);
		},
		function(loc, next) {
			fs.stat(this.loc = loc, next);
		},
		function(stat, next) {
			if (!stat.isDirectory()) {
				callback(null, this.loc);
				return;
			}
			exists(this.loc, ['package.json', 'index.js'], next);
		},
		function(paths, next) {
			if (/\.js$/i.test(paths[0])) {
				callback(null, paths[0]);
				return;
			}
			fs.readFile(paths[0], 'utf-8', next);
		},
		function(json) {
			try {
				json = JSON.parse(json);			
			} catch(err) {
				callback(err);
				return;
			}
			callback(null, path.join(this.loc, json.main || 'index.js'));
		}
	], callback);
};

var parseFile = function(source, cwd, callback) {
	var deps = parse(source);

	if (!deps.length) {
		callback(null, {});
		return;
	}
	common.step([
		function(next) {
			deps.forEach(function(dep) {
				if (/^[.\/]/.test(dep)) {
					next.parallel()(null, path.join(cwd, (/\.js$/i).test(dep) ? dep : dep + '.js'));
				} else {
					findModule(dep, cwd, next.parallel());
				}
			});			
		},
		function(targets) {
			var result = {};
			
			targets.forEach(function(target, i) {
				result[deps[i]] = target;
			});
			callback(null, result);			
		}
	], callback);
};

var loadFile = function(filename, callback) {
	var result = {main:filename};
	var cwd = path.dirname(filename);

	common.step([
		function(next) {
			fs.stat(filename, next);
		},
		function(stat, next) {
			result.modified = stat.mtime;
			fs.readFile(filename, 'utf-8', next);
		},
		function(src, next) {
			result.source = src;
			parseFile(src, cwd, next);
		},
		function(deps) {
			result.dependencies = deps;
			callback(null, result);
		}
	], callback);
};

var mapper = function(fn) {
	var cache = {};
	
	return function(path) {
		return cache[path] = cache[path] || fn(path, cache);
	};
};
var map = mapper(function(path, cache) {
	return common.encode(Object.keys(cache).length);
});
var hash = mapper(function(path) {
	return crypto.createHash('sha1').update(path).digest('hex');		
});
var indent = function(src) {
	return '\t'+src.split('\n').join('\n\t').trim()	
};
var requireJS = fs.readFileSync(__dirname+'/require.js', 'utf-8');

var cacheKey = function(source, options) {
	return hash(source+'&'+JSON.stringify(options));	
};

var resolve = function(source, options, callback) {
	var resolved = {};
	var exclude = {};
	var cwd = options.cwd || '.';

	var key = cacheKey(options.filename || source, options);

	if (options.cache && cache.has(key)) {
		callback(null, cache.get(key));
		return;
	}

	if (options.exclude === 1) {
		exclude = {entry:1};
	} else if (typeof options.exclude === 'string') {
		exclude[options.exclude] = 1;
	} else {
		exclude = options.exclude || exclude;
	}

	var resolveModule = function(mod, callback) {
		var deps = [];

		common.step([
			function(next) {				
				for (var i in mod.dependencies) {
					var dep = mod.dependencies[i];

					if (!resolved[dep]) {
						resolved[dep] = true;
						deps.push(dep);
					}
				}
				if (!deps.length) {
					callback();
					return;
				}
				deps.forEach(function(dep) {
					loadFile(dep, next.parallel());
				});
				
			},
			function(mods, next) {
				mods.forEach(function(mod, i) {
					resolved[deps[i]] = mod;
					resolveModule(mod, next.parallel());
				});
			},
			function() {
				callback();
			}
		], callback);
	};

	var main = {source:source, main:options.filename || 'source.js'};
	var entry;

	common.step([
		function(next) {
			if (cwd[0] === '/') {
				next(null, cwd);
			} else {
				fs.realpath(cwd, next);
			}
		},
		function(cwd, next) {
			parseFile(source, cwd, next);
		},
		function(deps, next) {
			main.dependencies = deps;
			main.files = options.filename ? [options.filename] : [];

			for (var i in deps) {
				main.files.push(deps[i]);
			}

			resolveModule(main, next);
		},
		function(next) {
			var result = (exclude.require ? '' : requireJS)+'\n';
			var m = options.hash ? hash : map;

			var inline = function(mod, pattern) {
				var params = {};
				var path = mod.main;
				var name = path.split('/');

				if (exclude[m(path)]) {
					return;
				}
				
				params.id = m(path);
				params.name = name.slice(name[name.length-1] === 'index.js' ? -2 : -1).join('/');
				params.src = indent(mod.source);
				params.map = {};

				for (var dep in mod.dependencies) {
					params.map[dep] = m(mod.dependencies[dep]);
				}

				params.map = JSON.stringify(params.map);

				result += common.format(pattern, params);				
			};

			for (var path in resolved) {
				inline(resolved[path], '// {name}\nrequire.define("{id}", {map}, function(module, exports, require) {\n{src}\n});\n');
			}

			if (exclude.entry) {
				inline(main, '// {name}\nrequire.entry({map});\n');
			} else {
				inline(main, '// {name}\nrequire.entry({map}, function(module, exports, require) {\n{src}\n});\n');
			}

			main.dependencies = {};

			for (var path in resolved) {
				main.dependencies[m(path)] = path;
			}
			if (options.scope) {
				result = common.format('(function(require) {\n{0}\n})();', indent(result));
			}

			if (!options.minify) {
				next(null, result);
				return;
			}
			minify(result, options.minify, next);
		},
		function(result) {
			main.compiled = result;

			if (options.cache) {
				cache.put(key, main.files, main);
			}

			callback(null, main);
		}
	], callback);
};
var stringifyFunction = function(fn) {
	// a lot of this is prettify
	fn = fn.toString().replace(/^[^{]*\{/, '').replace(/\}[^}]*$/, '');
	fn = fn.split('\n');

	var i = 0;

	while (fn.length && !fn[i].trim()) {
		i++;
	}
	if (!fn.length) {
		return fn.join('\n');
	}

	var indent = fn[i].match(/^(\s*)/g)[0];

	fn = fn.map(function(line) {
		return line.indexOf(indent) === 0 ? line.replace(indent, '') : line;
	});

	return fn.join('\n');
};
var resolveFile = function(entry, options, callback) {
	if (typeof entry === 'function') {
		resolve(stringifyFunction(entry), options, callback);
		return;
	}

	options = common.join(options);
	options.filename = entry;
	options.cwd = options.cwd || path.dirname(options.filename);

	common.step([
		function(next) {
			fs.readFile(entry, 'utf-8', next);
		},
		function(source, next) {
			resolve(source, options, next);
		},
		function(main) {
			callback(null, main);
		}
	], callback);	
};

var onmain = function(callback) {
	return common.fork(callback, function(main) {
		callback(null, main.compiled);
	});
};

exports.parseSource = function(source, options, callback) {
	if (!callback) {
		callback = options;
		options = {};
	}
	resolve(typeof source === 'function' ? stringifyFunction(source) : source, options, onmain(callback));
};
exports.parse = function(entry, options, callback) {	
	if (!callback) {
		callback = options;
		options = {};
	}
	resolveFile(entry, options, onmain(callback));
};
exports.parser = function(options) {
	var exclude = options.exclude || {};
	var single = queue(1);

	return function(entry, sub, callback) {
		if (!callback) {
			callback = sub;
			sub = {};
		}

		sub = common.join(options, sub);

		single(function(free) {
			callback = free.wrap(callback);

			sub.exclude = common.join(sub.exclude, exclude);
			
			resolveFile(entry, sub, common.fork(callback, function(main) {
				exclude = common.join(exclude, main.dependencies, {require:1});
				callback(null, main.compiled);
			}));			
		});
	};
};
exports.list = function(cwd, callback) {
	if (!callback) {
		callback = cwd;
		cwd = '.';
	}
	common.step([
		function(next) {
			fs.realpath(cwd, next);
		},
		function(cwd, next) {
			var paths = [];
			var parent;

			while (true) {
				paths.push(path.join(cwd, 'js_modules'));
				
				if (cwd === '/') {
					break;
				}

				cwd = path.join(cwd, '..');
			}

			if (!paths.length) {
				callback(null, []);
				return;
			}
			exists(paths, next);

		},
		function(paths, next) {			
			if (!paths.length) {
				callback(null, []);
				return;
			}
			
			this.paths = paths;

			paths.forEach(function(loc) {
				fs.readdir(loc, next.parallel());
			});
		},
		function(modules) {
			var result = {};
			var paths = this.paths;

			modules.forEach(function(module, i) {
				module.forEach(function(name) {
					if (name[0] === '.') {
						return;
					}
					result[name.replace(/\.js$/i, '')] = path.join(paths[i], name);
				});
			});
			callback(null, result);
		}
	]);
};